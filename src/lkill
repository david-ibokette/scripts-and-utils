#!/usr/bin/perl -w
use strict;
use Getopt::Long;

# Global variables
my $port;
my $verbose = 0;
my $force = 0;

main();

sub main {
    # Parse command line arguments
    GetOptions(
        'port=i' => \$port,
        'verbose' => \$verbose,
        'force' => \$force,
        'help' => \&show_help
    ) or die "Error in command line arguments\n";

    # Check for positional argument if --port wasn't used
    if (!$port && @ARGV > 0) {
        $port = $ARGV[0];
    }

    # Check if port argument was provided
    if (!$port) {
        print "Error: Port number is required\n";
        show_help();
        exit 1;
    }

    # Validate port number
    if ($port < 1 || $port > 65535) {
        print "Error: Port number must be between 1 and 65535\n";
        exit 1;
    }

    print "Searching for processes listening on port $port...\n" if $verbose;

    # Try to find the process using the port
    my $pid = find_process_by_port($port);
    
    if ($pid) {
        print "Found process with PID $pid listening on port $port\n";
        
        # Get process info for confirmation
        my $process_info = get_process_info($pid);
        print "Process details: $process_info\n" if $process_info;
    
        if ($force) {
            kill_process($pid);
        } else {
            # Ask user for confirmation
            print "Do you want to kill this process? (y/N): ";
            my $response = <STDIN>;
            chomp $response;
        
            if ($response =~ /^[yY](?:es)?$/) {
                kill_process($pid);
            } else {
                print "Process not killed.\n";
            }
        }
    } else {
        print "No process found listening on port $port\n";
    }
}

sub find_process_by_port {
    my $target_port = shift;
    my $pid;
    
    # Try lsof first (more reliable on macOS/Linux)
    if (system("which lsof > /dev/null 2>&1") == 0) {
        $pid = find_with_lsof($target_port);
        return $pid if $pid;
    }
    
    # Fallback to netstat
    if (system("which netstat > /dev/null 2>&1") == 0) {
        $pid = find_with_netstat($target_port);
        return $pid if $pid;
    }
    
    return undef;
}

sub find_with_lsof {
    my $target_port = shift;
    
    # lsof command to find processes listening on the port
    my $cmd = "lsof -ti:$target_port";
    my $output = `$cmd 2>/dev/null`;
    
    if ($output && $output =~ /^(\d+)$/) {
        return $1;
    }
    
    return undef;
}

sub find_with_netstat {
    my $target_port = shift;
    
    # Different netstat commands for different systems
    my @commands = (
        "netstat -tulpn 2>/dev/null | grep ':$target_port '",
        "netstat -tuln 2>/dev/null | grep ':$target_port '",
        "netstat -an 2>/dev/null | grep ':$target_port '"
    );
    
    foreach my $cmd (@commands) {
        my $output = `$cmd`;
        if ($output && $output =~ /(\d+)\s*$/) {
            return $1;
        }
    }
    
    return undef;
}

sub get_process_info {
    my $pid = shift;
    
    # Try to get process name and command line
    my $ps_cmd = "ps -p $pid -o pid,ppid,command 2>/dev/null";
    my $output = `$ps_cmd`;
    
    if ($output && $output =~ /^\s*\d+\s+\d+\s+(.+)$/m) {
        return $1;
    }
    
    return "PID: $pid";
}

sub kill_process {
    my $pid = shift;
    
    print "Killing process $pid...\n" if $verbose;
    
    # Try SIGTERM first (graceful shutdown)
    if (kill('TERM', $pid)) {
        print "Sent SIGTERM to process $pid\n";
        
        # Wait a moment for graceful shutdown
        sleep(2);
        
        # Check if process is still running
        if (kill(0, $pid)) {
            print "Process still running, sending SIGKILL...\n";
            if (kill('KILL', $pid)) {
                print "Process $pid killed with SIGKILL\n";
            } else {
                print "Failed to kill process $pid with SIGKILL\n";
                return 0;
            }
        } else {
            print "Process $pid terminated gracefully\n";
        }
    } else {
        print "Failed to send SIGTERM to process $pid\n";
        return 0;
    }
    
    return 1;
}

sub show_help {
    print <<EOF;
Usage: $0 <port_number> [options]
   or: $0 --port <port_number> [options]

Arguments:
    <port_number>     Port number to search for (required)

Options:
    --port <number>    Port number to search for (alternative to positional argument)
    --force           Kill process without confirmation
    --verbose         Enable verbose output
    --help            Show this help message

Examples:
    $0 3000
    $0 8080 --verbose
    $0 --port 3000
    $0 --port 8080 --verbose

This script finds processes listening on the specified port and allows you to kill them.
EOF
    exit 0;
}
